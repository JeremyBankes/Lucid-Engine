import Texture from './Texture.js';
/**
 * Represents a bitmap font in the BMFont format generated by https://github.com/libgdx/libgdx/wiki/Hiero
 * where each glyph can be individually drawn to a canvas rendering context
 */
class Font {

    /**
     * Creates an empty font, make a call to load() next
     */
    constructor() {
        this.face = null;
        this.lineHeight = 0;
        this.atlas = new Texture();
        this.glyphs = {};
        this._color = [255, 255, 255, 0];
    }

    get color() { return this._color; }

    set color(color) { this.atlas.floodColor(this._color = color); }

    /**
     * Loads a bitmap font (*.fnt) file
     * @param {string} source The address or URL of the BMFont to be loaded.
     * @returns {Promise} A promise that resolves if loading is successful, rejects otherwise.
     */
    async load(source) {
        if (!source) throw 'invalid sprite sheet source';
        const lines = (await fetch(source).then(response => response.text())).split('\n');
        const containingPath = source.substring(0, source.lastIndexOf('/') + 1);
        let padding = { top: 0, right: 0, bottom: 0, left: 0 };
        for (const line of lines) {
            const pieces = line.trim().split(/ +/);
            const command = pieces.shift();
            const properties = pieces.reduce((properties, piece) => {
                const pair = piece.split('=');
                properties[pair[0]] = pair[1].trim().replaceAll(/^"|"$/g, '');
                return properties;
            }, {});
            switch (command) {
                case 'info':
                    this.face = properties.face;
                    let paddingValues = properties.padding.split(',').map(parseFloat);
                    padding.top = paddingValues[0];
                    padding.right = paddingValues[1];
                    padding.bottom = paddingValues[2];
                    padding.left = paddingValues[3];
                    break;
                case 'common':
                    this.lineHeight = properties.lineHeight;
                    break;
                case 'page':
                    await this.atlas.load(`${containingPath}${properties.file}`);
                    break;
                case 'char':
                    this.glyphs[properties.id] = {
                        x: parseFloat(properties.x) + padding.left,
                        y: parseFloat(properties.y) + padding.top,
                        width: parseFloat(properties.width) - padding.left - padding.right,
                        height: parseFloat(properties.height) - padding.top - padding.bottom,
                        advance: parseFloat(properties.xadvance) - padding.left,
                        xOffset: parseFloat(properties.xoffset) + padding.left,
                        yOffset: parseFloat(properties.yoffset) + padding.top
                    };
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Determines the size in pixels of 'text' when rendered at 'scale' by this font
     * @param {string} text The text to determine the width of
     * @param {number} scale The scale of the font
     * @returns {number} The size in pixels of text
     */
    getTextWidth(text, scale = 1, letterSpacing = 0) {
        let width = 0;
        for (const character of text) width += (this.getGlyph(character).advance + letterSpacing) * scale;
        return width;
    }

    getTextHeight(scale = 1) {
        return this.lineHeight * scale;
    }

    /**
     * Retrieves a glyph object for 'character'
     * @param {string} character The character to retreive the glyph for
     * @returns {object} A glyph object with a x, y, width, height, advance, xOffset and yOffset
     */
    getGlyph(character) {
        const glyph = this.glyphs[character.charCodeAt(0)];
        return glyph || null;
    }

    /**
     * Draws text at the given location (top-left anchored)
     * @param {CanvasRenderingContext2D} context The context to draw the text to
     * @param {string} text The text to be drawn
     * @param {number} x The x coordinate of which to draw the text (from the left edge)
     * @param {number} y The y coordinate of which to the text (from the top edge)
     * @param {number} letterSpacing The number of pixels to add between characters (can be negative)
     * @param {number} scale The scale at which to draw the font (use whole numbers for best results)
     */
    draw(context, text, x, y, scale = 1, letterSpacing = 0) {
        for (const character of text) {
            const glyph = this.getGlyph(character);
            this.atlas.draw(context,
                Math.floor(x + glyph.xOffset * scale),
                Math.floor(y + glyph.yOffset * scale),
                Math.floor(glyph.width * scale),
                Math.floor(glyph.height * scale),
                glyph.x, glyph.y, glyph.width, glyph.height
            );
            x += (glyph.advance + letterSpacing) * scale;
        }
    }

}

export default Font;